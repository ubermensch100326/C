#include <stdio.h>

int main(void)
{
	// 우선 문제를 풀고 결과를 예측한다
	// 각 문제 부분만 드래그하고 Ctrl + K + U 누른 뒤 코드 돌려서 정답을 확인해보면 된다
	// 다시 주석 표시할 때는 드래그하고 Ctrl + K + C 누르면 된다
	// 위 단축키는 Visual Studio 기준이므로 Visual Studio Code를 사용하고 있다면 Alt + Shift + A를 누르면 된다
	// int 크기는 가장 일반적인 4바이트라고 가정하고 설명하였다
	// 해설편



	// 1번 문제
	/* int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	printf("arr의 값 : %d\n", arr);
	printf("&arr[0]의 값 : %d\n", &arr[0]); */
	// 1번 정답 및 해설
	// arr을 풀어서 쓰면 &arr[0]이므로 똑같은 값이 나온다
	// 어떤 배열을 선언했을 때 그 배열명은 첫 번째 요소의 주소를 의미한다
	// 첫 번째 요소라 함은 꼭 원소 하나만을 의미하는 것은 아니다
	// 만약 arr가 위에서 1차원 배열이 아니라 2차원 배열이라면 첫 번째 요소는 첫 번째 1차원 배열 자체를 의미한다
	// 여기서 왜 배열명이 변수명과는 달리 주소를 의미하는지 생각해볼 필요가 있다
	// 확실한 것은 아니지만 배열명이 배열의 요소를 표현하기 쉬워야 하기 때문인 것으로 보인다
	// 배열명이 첫 번째 요소의 주소를 의미하면 그 주소를 시작으로 하여 sizeof(*arr)씩 이동하면 다음 요소가 나온다
	// 즉, 첫 번째 요소의 주소를 의미할 뿐인데 이것을 이용하여 나머지 요소를 손쉽게 표현할 수 있다는 것이다
	// 참고로 포인터 주소를 나타낼 때 %p를 사용해도 되는데, 이는 16진수로 출력되기 때문에 알아보기 쉽지 않다
	// 따라서 여기에서는 %d만 사용했다는 것을 밝힌다



	// 2번 문제
	/*int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	for (int i = 0; i < 10; i++)
	{
		printf("&arr[%d]의 값 : %d\n", i, &arr[i]);
		printf("arr + %d의 값 : %d\n", i, arr + i);
	}*/
	// 2번 정답 및 해설
	// arr + i == arr + sizeof(*arr)*i == &arr[i]
	// 따라서 둘 다 i번째 요소의 주소값이 출력된다



	// 3번 문제
	/*int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	for (int* ptr = arr; ptr < arr + 10; ptr++)
	{
		printf("*ptr의 값 : %d\n", *ptr);
	}*/
	// 3번 정답 및 해설
	// ptr에다 arr을 넣었다는 것은 &arr[0]을 넣었다는 뜻이다
	// ptr은 일반적인 (배열 포인터 혹은 포인터 배열이 아닌) 포인터이다
	// ptr + 1 == ptr + sizeof(*ptr) == &ptr[1]
	// 여기에다 *을 붙였으므로 각 주소가 가리키는 요소가 출력된다
	// 따라서 arr의 각 요소가 순서대로 출력된다
	// 참고로 한 가지 주의해야 할 것이 있는데 ptr이 arr과 완전히 동일한 의미는 아니라는 것이다
	// arr은 포인터 '상수'고 ptr은 포인터 '변수'라고 할 수 있다
	// 즉, ptr에 arr을 할당했다가 다른 값으로 바꿀 수는 있지만 arr을 다른 값으로 바꾸는 것은 불가능하다



	// 4번 문제
	/*int arr[3] = { 1, 2, 3 };
	int* ptr = arr;
	for (int i = 0; i < 3; i++)
	{
		printf("*(ptr + %d)의 값 : %d\n", i, *(ptr + i));
		printf("ptr[%d]의 값 : %d\n", i, ptr[i]);
		printf("%d[ptr]의 값 : %d\n", i, i[ptr]);
	}*/
	// 4번 정답 및 해설
	// 셋 모두 똑같은 결과가 나온다
	// ptr[i] == *(ptr + i) == *(i + ptr) == i[ptr]



	// 5번 문제
	/*int arr[3] = { 1, 2, 3 };
	printf("arr의 값 : %d\n", arr);
	printf("arr + 1의 값 : %d\n", arr + 1);
	printf("&arr의 값 : %d\n", &arr);
	printf("&arr + 1의 값 : %d\n", &arr + 1);*/
	// 5번 정답 및 해설
	// arr + 1은 arr에 4를 더한 값이다
	// &arr + 1은 &arr에 12를 더한 값이다
	// arr과 &arr의 '값' 자체는 같지만 '의미'가 다르다
	// &arr + 1 == &arr + sizeof(*(&arr)) == &arr + sizeof(arr)
	// 바로 위의 식을 생각해보면 왜 12가 더해지는지 알 수 있다
	// 보다 직관적으로 왜 다른지 살펴보자면 arr은 arr[0]의 주소를 의미하는 반면, &arr은 배열 '자체'에다 &를 붙였으므로 배열 '자체'를 가리키고 따라서 배열 '자체'의 주소를 의미한다
	// 따라서 &arr이라고 했을 때 arr이라는 배열 '자체'를 가리키는 주소이므로 여기에 1을 더하면 그 배열 자체의 크기만큼 더해줘야 한다



	// 6번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	printf("&arr의 값 : %d\n", &arr);
	printf("&arr + 1의 값 : %d\n", &arr + 1);*/
	// 6번 정답 및 해설
	// &arr + 1은 &arr에서 12를 더한 값이 아닌 24를 더한 값이라는 것에 주의해야 한다
	// 어떤 배열에 &를 붙이면 그 배열 '자체'를 의미한다



	// 7번 문제
	/*int arr[3] = { 1, 2, 3 };
	int* ptr = arr;
	int* ptr2 = &arr;
	printf("ptr의 값 : %d\n", ptr);
	printf("ptr + 1의 값 : %d\n", ptr + 1);
	printf("ptr2의 값 : %d\n", ptr2);
	printf("ptr2 + 1의 값 : %d\n", ptr2 + 1);*/
	// 7번 정답 및 해설
	// ptr과 ptr2가 같은 값이라는 건 자명하다
	// 그런데 ptr + 1과 ptr2 + 1까지 같다는 것이 이상해 보일 수 있다
	// 여기서 중요한 점을 짚고 넘어가야 하는데, 포인터에 어떤 값을 넣을 때 (arr이든 &arr이든) 말 그대로 '값'만 들어가고 '의미'까지 들어가는 것이 아니다
	// 이 문제를 가지고 설명을 해보자면 arr과 &arr은 값은 같을지라도 1을 더해보면 알겠지만 의미는 다르다
	// 포인터에 arr을 넣든 &arr을 넣든 값 자체는 동일하므로 ptr이든 ptr2든 똑같다는 것이다
	// 그렇다면 '의미'까지 고려하려면 어떻게 해야 되는가?
	// 애초에 포인터 선언을 할 때 이것이 배열을 가리키는 '배열 포인터'라고 선언해야 한다
	// 우변에서 어떤 걸 넣어주든 '값'이 동일하면 똑같은 것이고 '의미'를 고려하고 싶다면 좌변에서 애초에 선언을 할 때 정확한 포인터 타입을 선언해야 한다
	// 구체적인 건 아래 문제들을 살펴보면 된다


	
	// 8번 문제
	/*int arr[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	int(*ptr)[3] = arr;
	printf("ptr의 값 : %d\n", ptr);
	printf("ptr + 1의 값 : %d\n", ptr + 1);
	printf("ptr[0] + 1의 값 : %d\n", ptr[0] + 1);
	printf("ptr[0][2]의 값 : %d\n", ptr[0][2]);*/
	// 8번 정답 및 해설
	// 일반적인 포인터가 아닌 int형 타입이고 크기가 3인 배열을 가리키는 '배열 포인터'를 선언하였다
	// ptr이 크기가 3인 배열 자체를 가리키므로 ptr + 1은 ptr의 값에서 12를 더한 값이다
	// ptr[0]은 {1, 2, 3}을 가리킨다
	// ptr[0] + 1 == ptr[0] + sizeof(*(ptr[0])) == &ptr[0][0] + sizeof(*(&ptr[0][0]))
	// 따라서 ptr[0] + 1의 값은 ptr[0]에다 4를 더한 값이다
	// 쉽게 생각하자면 ptr[0]은 {1, 2, 3}이라는 작은 배열 하나를 가리키는데, 1을 더하는 것이 {1, 2, 3}에서 한 요소의 크기를 더하는 것과 동일하다
	// arr = {1, 2, 3}일 때 arr + 1의 값이 arr의 값에서 4를 더한 것과 동일하게 생각하면 된다
	// 항상 포인터를 왜 사용하는지 생각해보면 된다
	// ptr[0]이 {1, 2, 3}을 가리킬 때 ptr[0]의 값은 {1, 2, 3}의 첫 번째 요소인 1의 주소값, 즉 &ptr[0][0]이다
	// 이 값을 이용하여 다른 요소인 2와 3도 표현할 수 있어야 한다
	// 따라서 ptr[0] + 1의 값은 ptr[0]에서 4를 더한 값이고 ptr[0] + 2의 값은 ptr[0]에서 8을 더한 값이다
	// 참고로 int(*ptr)[3] = arr에서 &arr을 넣어줘도 결과는 변하지 않는다
	// 우변은 어디까지나 '값'을 넣어주는 것이기 때문이다

	

	// 9번 문제
	/*int arr[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	int *ptr[3];
	for (int i = 0; i < 3; i++)
	{
		ptr[i] = arr[i];
		printf("ptr[%d]의 값 : %d\n", i, ptr[i]);
		printf("*ptr[%d]의 값 : %d\n", i, *ptr[i]);
	}*/
	// 9번 정답 및 해설
	// '배열 포인터'가 아닌 '포인터 배열'을 선언하였다
	// 포인터들이 원소인 '배열'이므로 각 자리에 주소값을 넣어줘야 한다
	// arr[0]은 {1, 2, 3}, arr[1]은 {4, 5, 6}, arr[2]는 {7, 8, 9}를 의미하고 각각 첫 번째 요소의 주소값을 가진다
	// 따라서 ptr[0], ptr[1], ptr[2]는 각각 &ptr[0][0], &ptr[1][0], &ptr[2][0]이므로 12씩 차이가 난다
	// *ptr[i] == *(&ptr[i][0]) == ptr[i][0]
	// *ptr[0]은 1, *ptr[1]은 4, *ptr[2]는 7이다



	// 10번 문제
	/*int arr[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	int(*ptr)[3] = arr;
	for (int i = 0; i < 5; i++)
	{
		printf("ptr[%d]의 값 : %d\n", i, ptr[i]);
		printf("&arr[%d]의 값 : %d\n", i, &arr[i]);
		printf("*ptr[%d]의 값 : %d\n", i, *ptr[i]);
		printf("(*ptr)[%d]의 값 : %d\n", i, (*ptr)[i]);
	}*/
	// 10번 정답 및 해설
	// ptr[i]는 12씩 건너뛴다
	// &arr[i]도 12씩 건너뛴다
	// *ptr[i]는 1, 4, 7에다 복잡한 값이 나온다
	// (*ptr)[i]는 1, 2, 3, 4, 5가 나온다
	// 이 문제에서 i < 3이 아니라 i < 5라고 준 것은 '배열 포인터'와 '포인터 배열'의 차이점을 확인하기 위해서이다
	// '포인터 배열'의 경우 처음에 선언한 포인터 배열의 크기를 초과하는 인덱스를 설정할 경우 오류가 뜬다
	// 그러나 '배열 포인터'는 말 그대로 주소이므로 더 초과해도 아무 문제가 없다
	// 그리고 *ptr[i]와 (*ptr)[i]의 값이 다른 것에 주의해야 한다
	// C에서 연산 순서는 꽤 중요한데 ( )와 [ ]가 *와 &보다 우선 순위가 높다
	// *ptr[i]는 ptr[i]의 역참조이므로 ptr[i]의 첫 번째 원소, 즉 1, 4, 7, 복잡한 값이 나온다
	// 반면 (*ptr)[i]에서 *ptr은 *(&ptr[0])에서 결과적으로 ptr[0]을 의미한다
	// ptr[0][i]이므로 순서대로 1, 2, 3, 4, 5가 나오는 것이다



	// 11번 문제
	/*int arr[2][3] = { {2, 4, 6}, {5, 10, 15} };
	printf("sizeof(arr)의 값 : %d\n", sizeof(arr));
	printf("sizeof(arr[0])의 값 : %d\n", sizeof(arr[0]));
	printf("sizeof(arr[0][0])의 값 : %d\n", sizeof(arr[0][0]));*/
	// 11번 정답 및 해설
	// sizeof(arr)은 24이다
	// sizeof(arr[0])은 12이다
	// sizeof(arr[0][0])은 4이다
	// 배열명은 2가지로 해석할 수 있는데 sizeof 연산자가 오면 그 배열 자체를, 나머지 경우에는 &배열명[0]의 값을 가진다
	// 물론 arr과 arr[0]처럼 같은 값을 가지더라도 다른 의미를 가지고 있을 수 있다



	// 12번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	int(*ptr)[3] = arr;
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			printf("ptr[%d][%d]의 값 : %d\n", i, j, ptr[i][j]);
		}
	}*/
	// 12번 정답 및 해설
	// 순서대로 1, 2, 3, 4, 5, 6이 나온다
	// 이렇게 2차원 배열을 포인터로 나타내고 싶다면 2차원 배열의 한 행을 가리키는 배열 포인터를 선언하면 된다



	// 13번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	for (int(*row)[3] = arr; row < arr + 2; row++)
	{
		for (int* col = row; col < *row + 3; col++)
		{
			printf("%d ", *col);
		}
		printf("\n");
	}*/
	// 13번 정답 및 해설
	// 순서대로 1, 2, 3, 4, 5, 6이 나온다
	// row는 arr의 한 행을 가리키는 배열 포인터로 12씩 움직인다
	// col은 row의 요소를 가리키는 포인터로 4씩 움직인다
	// *row == *(&row[0]) == row[0] == &row[0][0]


	
	// 14번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	printf("arr의 값 : %d\n", arr);
	printf("arr + 1의 값 : %d\n", arr + 1);
	printf("*arr의 값 : %d\n", *arr);
	printf("*arr + 1의 값 : %d\n", *arr + 1);
	printf("arr[0] + 1의 값 : %d\n", arr[0] + 1);
	printf("**arr의 값 : %d\n", **arr);*/
	// 14번 정답 및 해설
	// arr과 *arr의 값은 같다
	// arr + 1은 arr에서 12를 더한 값이다
	// *arr + 1은 *arr에서 4를 더한 값이다
	// arr[0] + 1은 *arr에서 4를 더한 값이다
	// arr[0] + 1과 *arr + 1은 동일한 의미다
	// **arr == **(&arr[0]) == *(arr[0]) == *(&arr[0][0]) == arr[0][0] == 1
	// 바로 위의 식을 직관적으로 생각해보자면 *arr은 arr[0]을 의미한다
	// {1, 2, 3}을 의미하는 arr[0]에다 또 역참조를 한 것이므로 첫 번째 요소인 1이 나온다



	// 15번 문제
	/*int arr[2][3] = { {1, 2, 3}, {7, 8, 9} };
	printf("arr[1]의 값 : %d\n", arr[1]);
	printf("*(&arr[1])의 값 : %d\n", *(&arr[1]));
	printf("&arr[1][0]의 값 : %d\n", &arr[1][0]);
	printf("&arr[1][1]의 값 : %d\n", &arr[1][1]);
	printf("(&arr[1])[0]의 값 : %d\n", (&arr[1])[0]);
	printf("(&arr[1])[1]의 값 : %d\n", (&arr[1])[1]);
	printf("*(&arr[1]) + 1의 값 : %d\n", *(&arr[1]) + 1);
	printf("arr[1] + 1의 값 : %d\n", arr[1] + 1);
	printf("&arr[1] + 1의 값 : %d\n", &arr[1] + 1);
	printf("&(*(&arr[1])) + 1의 값 : %d\n", &(*(&arr[1])) + 1);*/
	// 15번 정답 및 해설
	// arr[1]의 주소를 0이라고 가정하고 답을 적겠다
	// arr[1]부터 순서대로 0, 0, 0, 4, 0, 12, 4, 4, 12, 12이다
	// *와 &는 서로 상쇄된다고 봐도 무방하다
	// &arr[1]은 arr[1]이라는 배열 자체를 의미하므로 (&arr[1])[1]이 (&arr[1])[0]보다 12만큼 더 크다



	// 16번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	int* ptr = arr;
	printf("sizeof(arr)의 값 : %d\n", sizeof(arr));
	printf("sizeof(ptr)의 값 : %d\n", sizeof(ptr));
	printf("sizeof(*arr)의 값 : %d\n", sizeof(*arr));
	printf("sizeof(*ptr)의 값 : %d\n", sizeof(*ptr));
	printf("sizeof(&arr)의 값 : %d\n", sizeof(&arr));
	printf("sizeof(&ptr)의 값 : %d\n", sizeof(&ptr));*/
	// 16번 정답 및 해설
	// 순서대로 24, 8, 12, 4, 8, 8이다
	// 여기서 sizeof(ptr)이 8이라는 것이 의외일 수 있다
	// 그런데 sizeof(A) 연산자는 A의 메모리의 크기를 바이트 크기로 알려준다
	// 즉, ptr이 가리키고 있는 것의 크기가 아니라 ptr의 크기 자체를 알려주는 것이다
	// 만약 ptr이 가리키고 있는 것의 크기를 알고 싶다면 위에서 적은 것처럼 sizeof(*ptr)이라고 해야 한다
	// 또한, 64비트에서는 주소 (포인터)의 크기가 8이지만 32비트에서는 포인터의 크기가 4이다
	// 만약 32비트를 사용하고 있다면 sizeof(ptr)은 4가 나올 것이다
	// sizeof(*ptr)이 4라는 것도 조심하자
	// 배열 포인터가 아닌 일반적인 포인터로 선언했으므로 sizeof(*ptr)은 12가 아니라 4가 나오는 것이 맞다
	// sizeof(&arr), sizeof(&ptr) 모두 주소값이므로 8바이트를 차지한다



	// 17번 문제
	/*int arr[3] = { 1, 2, 3 };
	int(*ptr)[3] = arr;
	printf("ptr의 값 : %d\n", ptr);
	printf("*ptr의 값 : %d\n", *ptr);
	printf("sizeof(ptr)의 값 : %d\n", sizeof(ptr));
	printf("sizeof(*ptr)의 값 : %d\n", sizeof(*ptr));
	printf("sizeof(**ptr)의 값 : %d\n", sizeof(**ptr));*/
	// 17번 정답 및 해설
	// ptr과 *ptr의 '의미'는 다를지라도 '값'은 동일하다
	// sizeof(ptr)은 포인터라는 변수 타입의 크기이므로 8이다
	// sizeof(*ptr)은 배열 포인터가 가리키는 {1, 2, 3}의 크기이므로 12이다
	// sizeof(**ptr)은 배열 포인터가 가리키는 {1, 2, 3}에서 첫 번째 요소인 1의 크기이므로 4이다



	// 18번 문제
	/*int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	printf("arr[0][0] + 1의 값 : %d\n", arr[0][0] + 1);*/
	// 18번 정답 및 해설
	// 답은 2이다
	// 포인터 개념에 너무 빠지다 보면 arr[0][0] + 1에서 &arr[0][0][0]으로 생각하여 주소값에서 1만 더하는 걸로 생각할 수 있다
	// 그러나 어디까지나 가장 작은 단위는 변수 하나임을 명심하자
	// 여기에서와 같이 arr[0][0]이 1을 가리키므로 더 이상 분해해서 생각할 수는 없는 것이다
	// 만약 arr[0][0]이 변수 하나를 의미하는 게 아니라 배열을 의미한다면 주소값이 나오겠지만 여기는 변수 하나를 가리키므로 변수가 바로 나온다
	// 이게 무슨 소리인지 모르겠고 너무 당연하게 2라고 생각된다면 그냥 넘어가면 된다



	// 19번 문제
	/*int a = 20;
	int* ptr = &a;
	int* ptr_ptr1 = &ptr;
	int** ptr_ptr2 = &ptr;
	printf("ptr의 값 : %d\n", ptr);
	printf("ptr_ptr1의 값 : %d\n", ptr_ptr1);
	printf("ptr_ptr2의 값 : %d\n", ptr_ptr2);
	printf("**ptr_ptr1의 값 : %d\n", **ptr_ptr1);
	printf("**ptr_ptr2의 값 : %d\n", **ptr_ptr2);
	printf("sizeof(*ptr_ptr1)의 값 : %d\n", sizeof(*ptr_ptr1));
	printf("sizeof(*ptr_ptr2)의 값 : %d\n", sizeof(*ptr_ptr2));*/
	// 19번 정답 및 해설
	// 우선 문제의 코드를 돌려보면 오류가 뜨는데 이에 관해서는 아래에 자세하게 설명하였다
	// printf("**ptr_ptr1의 값 : %d\n", **ptr_ptr1)만 주석 처리하고 나머지 답을 확인해보면 된다
	// ptr은 a를 가리키고 따라서 a의 주소를 의미한다
	// ptr_ptr1과 ptr_ptr2 모두 ptr을 가리키게 하였고 ptr의 주소값을 저장하도록 하였다
	// 그렇다면 ptr_ptr1과 ptr_ptr2는 동일한 의미인가 생각할 수 있는데 전혀 그렇지 않다
	// ptr, ptr_ptr1, ptr_ptr2는 자명하므로 설명은 생략하겠다
	// 주목할 부분은 **ptr_ptr1과 **ptr_ptr2인데 **ptr_ptr2는 정상적으로 20으로 출력되는 반면 **ptr_ptr1은 오류가 나오는 것을 확인할 수 있다
	// 분명 둘 다 ptr을 가리키게 하였고 ptr의 주소를 의미하므로 역참조를 2번 (**) 하면 20이 나와야 할 것 같은데 하나만 정상적으로 나온다
	// 왜냐하면 포인터를 선언할 때 하나는 일반 포인터, 다른 하나는 이중 포인터로 선언했기 때문이다
	// 우선 int* ptr_ptr1 = &ptr에서 정의에 의하면 ptr_ptr1이 역참조를 1번 (*) 하면 int 변수를 가리킨다는 뜻이다
	// 즉, int* ptr_ptr1 = &ptr에서 ptr_ptr1을 1번 역참조하면 ptr의 '값'과 동일한 '값'이 나오지만 변수 타입은 포인터 (주소)가 아닌 int라는 것이다
	// 이중 포인터 목적상 ptr '값'의 타입을 포인터로 고려해야 하는데 int로 고려해버리게 되는 것이다
	// 따라서 **ptr_ptr1은 int 변수에다 역참조를 한 것이므로 포인터가 아닌 변수에 역참조를 하게 된 셈이라 오류가 나온다
	// 반면 int** ptr_ptr2 = &ptr에서는 정의에 의하면 ptr_ptr2가 역참조를 2번 (*) 하면 int 변수를 가리킨다는 뜻이다
	// 즉, int** ptr_ptr2 = &ptr에서 ptr_ptr2를 2번 역참조하면 20이라는 '값'이 나오고 변수 타입 또한 int로 제대로 된 결과를 얻는다는 것이다
	// 결국 이중 포인터를 비롯하여 다중 포인터를 사용할 때는 선언할 때 asterisk (*)를 그만큼 붙여줘야 한다
	// 참고로 asterisk는 곱하기, 포인터 변수 선언, 역참조 (메모리로 접근) 이렇게 3가지로 쓰일 수 있기 때문에 주의해야 한다
	// 위 설명을 이해하고 나면 sizeof(*ptr_ptr1)과 sizeof(*ptr_ptr2)의 결과를 납득할 수 있다
	// *ptr_ptr1은 int 변수이므로 sizeof(*ptr_ptr1)은 4이다
	// *ptr_ptr2는 포인터 변수이므로 sizeof(*ptr_ptr2)는 8이다 (64비트 기준)
	// 비슷하지만 조금 다르게 int* ptr = &a을 ptr에 int 변수의 주소를 저장하겠다고 볼 수 있는데 이게 더 적절한 해석인 것 같다
	// asterisk가 3가지 의미로 쓰일 수 있다고 했는데 선언할 때는 int*, int** 등은 ptr 변수의 타입을 알려주는 셈이다



	// 20번 문제
	/*int i = 0;
	int* ptr = &i;
	printf("&(&i)의 값 : %d\n", &(&i));
	printf("&ptr의 값 : %d\n", &ptr);*/
	// 20번 정답 및 해설
	// &(&i)는 오류가 뜨지만 &ptr은 정상적으로 출력된다
	// & (ampersand)의 피연산자에는 rvalue가 아닌 lvalue가 들어가야 한다
	// 그러나 &i는 rvalue여서 오류가 뜬다
	// ptr은 lvalue여서 정상적으로 출력된다
	// ptr이 &i이므로 &ptr이 &(&i)와 같다고 착각할 수 있는데 주의해야 한다



	return 0;
}